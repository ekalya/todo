/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { entityExists, isObject, toBoolean } from './utils';
export class AkitaError extends Error {
    /**
     * @param {?} message
     */
    constructor(message) {
        super(message);
    }
}
export class AkitaImmutabilityError extends AkitaError {
    /**
     * @param {?} storeName
     */
    constructor(storeName) {
        super(`The new state should be immutable. Make sure to return a new immutable state. \n store: \n ${storeName}`);
    }
}
export class AkitaEntityNotExistsError extends AkitaError {
    /**
     * @param {?} id
     */
    constructor(id) {
        super(`Entity ${id} does not exists`);
    }
}
export class AkitaNoActiveError extends AkitaError {
    constructor() {
        super(`Active is null/undefined`);
    }
}
export class AkitaInvalidEntityState extends AkitaError {
    constructor() {
        super(`Entity state is invalid`);
    }
}
export class AkitaUpdateIdKeyError extends AkitaError {
    constructor() {
        super(`Updating entity id is not permitted when updating many entities`);
    }
}
/**
 * @param {?} id
 * @param {?} entities
 * @return {?}
 */
export function assertEntityExists(id, entities) {
    if (!entityExists(id, entities)) {
        throw new AkitaEntityNotExistsError(id);
    }
}
/**
 * @param {?} store
 * @return {?}
 */
export function assertActive(store) {
    if (!toBoolean(store.active)) {
        throw new AkitaNoActiveError();
    }
}
/**
 * @param {?} state
 * @return {?}
 */
export function assertEntityState(state) {
    /** @type {?} */
    const assertEntities = isObject(state);
    if (!assertEntities) {
        throw new AkitaInvalidEntityState();
    }
}
/**
 * @param {?} name
 * @param {?} className
 * @return {?}
 */
export function assertDecorator(name, className) {
    if (!name) {
        console.error(`@StoreConfig({ name }) is missing in ${className}`);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvZXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUc1RCxNQUFNLGlCQUFrQixTQUFRLEtBQUs7Ozs7SUFDbkMsWUFBWSxPQUFlO1FBQ3pCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNoQjtDQUNGO0FBRUQsTUFBTSw2QkFBOEIsU0FBUSxVQUFVOzs7O0lBQ3BELFlBQVksU0FBUztRQUNuQixLQUFLLENBQUMsOEZBQThGLFNBQVMsRUFBRSxDQUFDLENBQUM7S0FDbEg7Q0FDRjtBQUVELE1BQU0sZ0NBQWlDLFNBQVEsVUFBVTs7OztJQUN2RCxZQUFZLEVBQUU7UUFDWixLQUFLLENBQUMsVUFBVSxFQUFFLGtCQUFrQixDQUFDLENBQUM7S0FDdkM7Q0FDRjtBQUVELE1BQU0seUJBQTBCLFNBQVEsVUFBVTtJQUNoRDtRQUNFLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0tBQ25DO0NBQ0Y7QUFFRCxNQUFNLDhCQUErQixTQUFRLFVBQVU7SUFDckQ7UUFDRSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztLQUNsQztDQUNGO0FBRUQsTUFBTSw0QkFBNkIsU0FBUSxVQUFVO0lBQ25EO1FBQ0UsS0FBSyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7S0FDMUU7Q0FDRjs7Ozs7O0FBRUQsTUFBTSw2QkFBNkIsRUFBTSxFQUFFLFFBQVE7SUFDakQsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLEVBQUU7UUFDL0IsTUFBTSxJQUFJLHlCQUF5QixDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ3pDO0NBQ0Y7Ozs7O0FBRUQsTUFBTSx1QkFBdUIsS0FBSztJQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUM1QixNQUFNLElBQUksa0JBQWtCLEVBQUUsQ0FBQztLQUNoQztDQUNGOzs7OztBQUVELE1BQU0sNEJBQTRCLEtBQXVCOztJQUN2RCxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFdkMsSUFBSSxDQUFDLGNBQWMsRUFBRTtRQUNuQixNQUFNLElBQUksdUJBQXVCLEVBQUUsQ0FBQztLQUNyQztDQUNGOzs7Ozs7QUFFRCxNQUFNLDBCQUEwQixJQUFZLEVBQUUsU0FBaUI7SUFDN0QsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLFNBQVMsRUFBRSxDQUFDLENBQUM7S0FDcEU7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVudGl0eUV4aXN0cywgaXNPYmplY3QsIHRvQm9vbGVhbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgRW50aXR5U3RhdGUsIElEIH0gZnJvbSAnLi4vYXBpL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEFraXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBa2l0YUltbXV0YWJpbGl0eUVycm9yIGV4dGVuZHMgQWtpdGFFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlTmFtZSkge1xuICAgIHN1cGVyKGBUaGUgbmV3IHN0YXRlIHNob3VsZCBiZSBpbW11dGFibGUuIE1ha2Ugc3VyZSB0byByZXR1cm4gYSBuZXcgaW1tdXRhYmxlIHN0YXRlLiBcXG4gc3RvcmU6IFxcbiAke3N0b3JlTmFtZX1gKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWtpdGFFbnRpdHlOb3RFeGlzdHNFcnJvciBleHRlbmRzIEFraXRhRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHN1cGVyKGBFbnRpdHkgJHtpZH0gZG9lcyBub3QgZXhpc3RzYCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFraXRhTm9BY3RpdmVFcnJvciBleHRlbmRzIEFraXRhRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgQWN0aXZlIGlzIG51bGwvdW5kZWZpbmVkYCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFraXRhSW52YWxpZEVudGl0eVN0YXRlIGV4dGVuZHMgQWtpdGFFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBFbnRpdHkgc3RhdGUgaXMgaW52YWxpZGApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBa2l0YVVwZGF0ZUlkS2V5RXJyb3IgZXh0ZW5kcyBBa2l0YUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYFVwZGF0aW5nIGVudGl0eSBpZCBpcyBub3QgcGVybWl0dGVkIHdoZW4gdXBkYXRpbmcgbWFueSBlbnRpdGllc2ApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbnRpdHlFeGlzdHMoaWQ6IElELCBlbnRpdGllcykge1xuICBpZiAoIWVudGl0eUV4aXN0cyhpZCwgZW50aXRpZXMpKSB7XG4gICAgdGhyb3cgbmV3IEFraXRhRW50aXR5Tm90RXhpc3RzRXJyb3IoaWQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBY3RpdmUoc3RvcmUpIHtcbiAgaWYgKCF0b0Jvb2xlYW4oc3RvcmUuYWN0aXZlKSkge1xuICAgIHRocm93IG5ldyBBa2l0YU5vQWN0aXZlRXJyb3IoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW50aXR5U3RhdGUoc3RhdGU6IEVudGl0eVN0YXRlPGFueT4pIHtcbiAgY29uc3QgYXNzZXJ0RW50aXRpZXMgPSBpc09iamVjdChzdGF0ZSk7XG5cbiAgaWYgKCFhc3NlcnRFbnRpdGllcykge1xuICAgIHRocm93IG5ldyBBa2l0YUludmFsaWRFbnRpdHlTdGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWNvcmF0b3IobmFtZTogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZykge1xuICBpZiAoIW5hbWUpIHtcbiAgICBjb25zb2xlLmVycm9yKGBAU3RvcmVDb25maWcoeyBuYW1lIH0pIGlzIG1pc3NpbmcgaW4gJHtjbGFzc05hbWV9YCk7XG4gIH1cbn1cbiJdfQ==