/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { AkitaUpdateIdKeyError, assertEntityExists, assertEntityState } from './error';
import { entityExists, isFunction, isPlainObject, resetActive } from './utils';
export class CRUD {
    /**
     * @template S, E
     * @param {?} state
     * @param {?} entities
     * @param {?} entityClass
     * @param {?} idKey
     * @return {?}
     */
    _set(state, entities, entityClass, idKey) {
        /** @type {?} */
        let ids;
        /** @type {?} */
        let normalized;
        if ((/** @type {?} */ (entities)).ids && (/** @type {?} */ (entities)).entities) {
            ids = (/** @type {?} */ (entities)).ids;
            normalized = (/** @type {?} */ (entities)).entities;
        }
        else {
            /** @type {?} */
            const isArray = Array.isArray(entities);
            normalized = entities;
            if (isArray) {
                normalized = /** @type {?} */ (this.keyBy(/** @type {?} */ (entities), entityClass, idKey));
            }
            else {
                assertEntityState(entities);
            }
            ids = isArray ? (/** @type {?} */ (entities)).map(entity => entity[idKey]) : Object.keys(/** @type {?} */ (normalized)).map(id => entities[id][idKey]);
        }
        /** @type {?} */
        const newState = Object.assign({}, (/** @type {?} */ (state)), { entities: normalized, ids, loading: false });
        if (resetActive(newState)) {
            newState.active = null;
        }
        return newState;
    }
    /**
     * @template T
     * @param {?} state
     * @param {?} id
     * @param {?} entity
     * @return {?}
     */
    _replaceEntity(state, id, entity) {
        return Object.assign({}, (/** @type {?} */ (state)), { entities: Object.assign({}, state.entities, { [id]: entity }) });
    }
    /**
     * @template S, E
     * @param {?} state
     * @param {?} entities
     * @param {?} idKey
     * @return {?}
     */
    _add(state, entities, idKey) {
        /** @type {?} */
        let addedEntities = {};
        /** @type {?} */
        let addedIds = [];
        for (let i = 0; i < entities.length; i++) {
            /** @type {?} */
            const entity = entities[i];
            /** @type {?} */
            const entityId = entity[idKey];
            if (!entityExists(entityId, state.entities)) {
                addedEntities[entityId] = entity;
                addedIds.push(entityId);
            }
        }
        return Object.assign({}, (/** @type {?} */ (state)), { entities: Object.assign({}, state.entities, addedEntities), ids: [...state.ids, ...addedIds] });
    }
    /**
     * @template T
     * @param {?} state
     * @param {?} ids
     * @param {?} newStateOrFn
     * @param {?} idKey
     * @return {?}
     */
    _update(state, ids, newStateOrFn, idKey) {
        /** @type {?} */
        const updatedEntities = {};
        /** @type {?} */
        let isUpdatingIdKey = false;
        /** @type {?} */
        let idToUpdate;
        for (let i = 0; i < ids.length; i++) {
            /** @type {?} */
            const id = ids[i];
            idToUpdate = id;
            assertEntityExists(id, state.entities);
            /** @type {?} */
            const oldEntity = state.entities[id];
            /** @type {?} */
            const newState = isFunction(newStateOrFn) ? newStateOrFn(oldEntity) : newStateOrFn;
            if (newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey]) {
                if (ids.length > 1) {
                    throw new AkitaUpdateIdKeyError();
                }
                isUpdatingIdKey = true;
                idToUpdate = newState[idKey];
            }
            /** @type {?} */
            let newEntity;
            /** @type {?} */
            const merged = Object.assign({}, oldEntity, newState);
            if (isPlainObject(oldEntity)) {
                newEntity = merged;
            }
            else {
                newEntity = new oldEntity.constructor(merged);
            }
            updatedEntities[idToUpdate] = newEntity;
        }
        /** @type {?} */
        let updatedIds = state.ids;
        /** @type {?} */
        let stateEntities = state.entities;
        if (isUpdatingIdKey) {
            const [id] = ids;
            const _a = state.entities, _b = id, deletedEntity = _a[_b], rest = tslib_1.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            stateEntities = rest;
            updatedIds = state.ids.map(current => (current === id ? idToUpdate : current));
        }
        return Object.assign({}, (/** @type {?} */ (state)), { entities: Object.assign({}, stateEntities, updatedEntities), ids: updatedIds });
    }
    /**
     * @template T
     * @param {?} state
     * @param {?} ids
     * @return {?}
     */
    _remove(state, ids) {
        if (!ids)
            return this._removeAll(state);
        /** @type {?} */
        const removed = ids.reduce((acc, id) => {
            const _a = id, entity = acc[_a], rest = tslib_1.__rest(acc, [typeof _a === "symbol" ? _a : _a + ""]);
            return rest;
        }, state.entities);
        /** @type {?} */
        const newState = Object.assign({}, (/** @type {?} */ (state)), { entities: removed, ids: state.ids.filter(current => ids.indexOf(current) === -1) });
        if (resetActive(newState)) {
            newState.active = null;
        }
        return newState;
    }
    /**
     * @template T
     * @param {?} state
     * @return {?}
     */
    _removeAll(state) {
        /** @type {?} */
        const newState = Object.assign({}, (/** @type {?} */ (state)), { entities: {}, ids: [], active: null });
        return newState;
    }
    /**
     * @param {?} entities
     * @param {?=} entityClass
     * @param {?=} id
     * @return {?}
     */
    keyBy(entities, entityClass, id = 'id') {
        /** @type {?} */
        const acc = {};
        for (let i = 0, len = entities.length; i < len; i++) {
            /** @type {?} */
            const entity = entities[i];
            acc[entity[id]] = entityClass ? new entityClass(entity) : entity;
        }
        return acc;
    }
}
/** @type {?} */
export const _crud = new CRUD();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J1ZC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BkYXRvcmFtYS9ha2l0YS8iLCJzb3VyY2VzIjpbInNyYy9pbnRlcm5hbC9jcnVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFL0UsTUFBTTs7Ozs7Ozs7O0lBQ0osSUFBSSxDQUFPLEtBQVEsRUFBRSxRQUF3QyxFQUFFLFdBQXVCLEVBQUUsS0FBSzs7UUFDM0YsSUFBSSxHQUFHLENBQWE7O1FBQXBCLElBQVMsVUFBVSxDQUFDO1FBRXBCLElBQUksbUJBQUMsUUFBdUIsRUFBQyxDQUFDLEdBQUcsSUFBSSxtQkFBQyxRQUF1QixFQUFDLENBQUMsUUFBUSxFQUFFO1lBQ3ZFLEdBQUcsR0FBRyxtQkFBQyxRQUF1QixFQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3BDLFVBQVUsR0FBRyxtQkFBQyxRQUF1QixFQUFDLENBQUMsUUFBUSxDQUFDO1NBQ2pEO2FBQU07O1lBQ0wsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN4QyxVQUFVLEdBQUcsUUFBUSxDQUFDO1lBRXRCLElBQUksT0FBTyxFQUFFO2dCQUNYLFVBQVUscUJBQUcsSUFBSSxDQUFDLEtBQUssbUJBQUMsUUFBZSxHQUFFLFdBQVcsRUFBRSxLQUFLLENBQVEsQ0FBQSxDQUFDO2FBQ3JFO2lCQUFNO2dCQUNMLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzdCO1lBRUQsR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsbUJBQUMsUUFBZSxFQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLG1CQUFDLFVBQXdCLEVBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUN2STs7UUFFRCxNQUFNLFFBQVEscUJBQ1QsbUJBQUMsS0FBWSxFQUFDLElBQ2pCLFFBQVEsRUFBRSxVQUFVLEVBQ3BCLEdBQUcsRUFDSCxPQUFPLEVBQUUsS0FBSyxJQUNkO1FBRUYsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDekIsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7U0FDeEI7UUFFRCxPQUFPLFFBQVEsQ0FBQztLQUNqQjs7Ozs7Ozs7SUFFRCxjQUFjLENBQXdCLEtBQVEsRUFBRSxFQUFNLEVBQUUsTUFBTTtRQUM1RCx5QkFDSyxtQkFBQyxLQUFZLEVBQUMsSUFDakIsUUFBUSxvQkFDSCxLQUFLLENBQUMsUUFBUSxJQUNqQixDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sT0FFZDtLQUNIOzs7Ozs7OztJQUVELElBQUksQ0FBMkIsS0FBUSxFQUFFLFFBQWEsRUFBRSxLQUFLOztRQUMzRCxJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUM7O1FBQ3ZCLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUVsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs7WUFDeEMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOztZQUMzQixNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFL0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUMzQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDO2dCQUNqQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3pCO1NBQ0Y7UUFFRCx5QkFDSyxtQkFBQyxLQUFZLEVBQUMsSUFDakIsUUFBUSxvQkFDSCxLQUFLLENBQUMsUUFBUSxFQUNkLGFBQWEsR0FFbEIsR0FBRyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsUUFBUSxDQUFDLElBQ2hDO0tBQ0g7Ozs7Ozs7OztJQUVELE9BQU8sQ0FBd0IsS0FBUSxFQUFFLEdBQVMsRUFBRSxZQUFxRCxFQUFFLEtBQWE7O1FBQ3RILE1BQU0sZUFBZSxHQUFHLEVBQUUsQ0FBQzs7UUFFM0IsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDOztRQUM1QixJQUFJLFVBQVUsQ0FBSztRQUVuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs7WUFDbkMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLFVBQVUsR0FBRyxFQUFFLENBQUM7WUFDaEIsa0JBQWtCLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzs7WUFFdkMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7WUFDckMsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztZQUVuRixJQUFJLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDMUUsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDbEIsTUFBTSxJQUFJLHFCQUFxQixFQUFFLENBQUM7aUJBQ25DO2dCQUNELGVBQWUsR0FBRyxJQUFJLENBQUM7Z0JBQ3ZCLFVBQVUsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDOUI7O1lBRUQsSUFBSSxTQUFTLENBQUM7O1lBRWQsTUFBTSxNQUFNLHFCQUNQLFNBQVMsRUFDVCxRQUFRLEVBQ1g7WUFFRixJQUFJLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDNUIsU0FBUyxHQUFHLE1BQU0sQ0FBQzthQUNwQjtpQkFBTTtnQkFDTCxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQy9DO1lBRUQsZUFBZSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFNBQVMsQ0FBQztTQUN6Qzs7UUFFRCxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDOztRQUMzQixJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO1FBQ25DLElBQUksZUFBZSxFQUFFO1lBQ25CLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDakIsMkJBQVEsT0FBSSxFQUFKLHNCQUFtQixFQUFFLGtFQUFPLENBQW9CO1lBQ3hELGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDckIsVUFBVSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDaEY7UUFFRCx5QkFDSyxtQkFBQyxLQUFZLEVBQUMsSUFDakIsUUFBUSxvQkFDSCxhQUFhLEVBQ2IsZUFBZSxHQUVwQixHQUFHLEVBQUUsVUFBVSxJQUNmO0tBQ0g7Ozs7Ozs7SUFFRCxPQUFPLENBQXdCLEtBQVEsRUFBRSxHQUFnQjtRQUN2RCxJQUFJLENBQUMsR0FBRztZQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7UUFFeEMsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRTtZQUNyQyxNQUFRLE9BQUksRUFBSixnQkFBWSxFQUFFLG1FQUFPLENBQVM7WUFDdEMsT0FBTyxJQUFJLENBQUM7U0FDYixFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzs7UUFDbkIsTUFBTSxRQUFRLHFCQUNULG1CQUFDLEtBQVksRUFBQyxJQUNqQixRQUFRLEVBQUUsT0FBTyxFQUNqQixHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQzdEO1FBRUYsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDekIsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7U0FDeEI7UUFFRCxPQUFPLFFBQVEsQ0FBQztLQUNqQjs7Ozs7O0lBRU8sVUFBVSxDQUF3QixLQUFROztRQUNoRCxNQUFNLFFBQVEscUJBQ1QsbUJBQUMsS0FBWSxFQUFDLElBQ2pCLFFBQVEsRUFBRSxFQUFFLEVBQ1osR0FBRyxFQUFFLEVBQUUsRUFDUCxNQUFNLEVBQUUsSUFBSSxJQUNaO1FBRUYsT0FBTyxRQUFRLENBQUM7Ozs7Ozs7O0lBR1YsS0FBSyxDQUFDLFFBQWUsRUFBRSxXQUEwQixFQUFFLEVBQUUsR0FBRyxJQUFJOztRQUNsRSxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFFZixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFOztZQUNuRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztTQUNsRTtRQUVELE9BQU8sR0FBRyxDQUFDOztDQUVkOztBQUVELGFBQWEsS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnRpdGllcywgRW50aXR5U3RhdGUsIEhhc2hNYXAsIElELCBOZXdhYmxlIH0gZnJvbSAnLi4vYXBpL3R5cGVzJztcbmltcG9ydCB7IEFraXRhVXBkYXRlSWRLZXlFcnJvciwgYXNzZXJ0RW50aXR5RXhpc3RzLCBhc3NlcnRFbnRpdHlTdGF0ZSB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgZW50aXR5RXhpc3RzLCBpc0Z1bmN0aW9uLCBpc1BsYWluT2JqZWN0LCByZXNldEFjdGl2ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgQ1JVRCB7XG4gIF9zZXQ8UywgRT4oc3RhdGU6IFMsIGVudGl0aWVzOiBFW10gfCBIYXNoTWFwPEU+IHwgRW50aXRpZXM8RT4sIGVudGl0eUNsYXNzOiBOZXdhYmxlPEU+LCBpZEtleSk6IFMge1xuICAgIGxldCBpZHMsIG5vcm1hbGl6ZWQ7XG5cbiAgICBpZiAoKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5pZHMgJiYgKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5lbnRpdGllcykge1xuICAgICAgaWRzID0gKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5pZHM7XG4gICAgICBub3JtYWxpemVkID0gKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5lbnRpdGllcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZW50aXRpZXMpO1xuICAgICAgbm9ybWFsaXplZCA9IGVudGl0aWVzO1xuXG4gICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICBub3JtYWxpemVkID0gdGhpcy5rZXlCeShlbnRpdGllcyBhcyBFW10sIGVudGl0eUNsYXNzLCBpZEtleSkgYXMgRVtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0RW50aXR5U3RhdGUoZW50aXRpZXMpO1xuICAgICAgfVxuXG4gICAgICBpZHMgPSBpc0FycmF5ID8gKGVudGl0aWVzIGFzIEVbXSkubWFwKGVudGl0eSA9PiBlbnRpdHlbaWRLZXldKSA6IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWQgYXMgSGFzaE1hcDxFPikubWFwKGlkID0+IGVudGl0aWVzW2lkXVtpZEtleV0pO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgLi4uKHN0YXRlIGFzIGFueSksXG4gICAgICBlbnRpdGllczogbm9ybWFsaXplZCxcbiAgICAgIGlkcyxcbiAgICAgIGxvYWRpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChyZXNldEFjdGl2ZShuZXdTdGF0ZSkpIHtcbiAgICAgIG5ld1N0YXRlLmFjdGl2ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbiAgX3JlcGxhY2VFbnRpdHk8VCBleHRlbmRzIEVudGl0eVN0YXRlPihzdGF0ZTogVCwgaWQ6IElELCBlbnRpdHkpOiBUIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uKHN0YXRlIGFzIGFueSksXG4gICAgICBlbnRpdGllczoge1xuICAgICAgICAuLi5zdGF0ZS5lbnRpdGllcyxcbiAgICAgICAgW2lkXTogZW50aXR5XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9hZGQ8UyBleHRlbmRzIEVudGl0eVN0YXRlLCBFPihzdGF0ZTogUywgZW50aXRpZXM6IEVbXSwgaWRLZXkpOiBTIHtcbiAgICBsZXQgYWRkZWRFbnRpdGllcyA9IHt9O1xuICAgIGxldCBhZGRlZElkcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRpdGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXNbaV07XG4gICAgICBjb25zdCBlbnRpdHlJZCA9IGVudGl0eVtpZEtleV07XG5cbiAgICAgIGlmICghZW50aXR5RXhpc3RzKGVudGl0eUlkLCBzdGF0ZS5lbnRpdGllcykpIHtcbiAgICAgICAgYWRkZWRFbnRpdGllc1tlbnRpdHlJZF0gPSBlbnRpdHk7XG4gICAgICAgIGFkZGVkSWRzLnB1c2goZW50aXR5SWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi4oc3RhdGUgYXMgYW55KSxcbiAgICAgIGVudGl0aWVzOiB7XG4gICAgICAgIC4uLnN0YXRlLmVudGl0aWVzLFxuICAgICAgICAuLi5hZGRlZEVudGl0aWVzXG4gICAgICB9LFxuICAgICAgaWRzOiBbLi4uc3RhdGUuaWRzLCAuLi5hZGRlZElkc11cbiAgICB9O1xuICB9XG5cbiAgX3VwZGF0ZTxUIGV4dGVuZHMgRW50aXR5U3RhdGU+KHN0YXRlOiBULCBpZHM6IElEW10sIG5ld1N0YXRlT3JGbjogb2JqZWN0IHwgKChlOiBSZWFkb25seTxhbnk+KSA9PiBvYmplY3QpLCBpZEtleTogc3RyaW5nKTogVCB7XG4gICAgY29uc3QgdXBkYXRlZEVudGl0aWVzID0ge307XG5cbiAgICBsZXQgaXNVcGRhdGluZ0lkS2V5ID0gZmFsc2U7XG4gICAgbGV0IGlkVG9VcGRhdGU6IElEO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlkID0gaWRzW2ldO1xuICAgICAgaWRUb1VwZGF0ZSA9IGlkO1xuICAgICAgYXNzZXJ0RW50aXR5RXhpc3RzKGlkLCBzdGF0ZS5lbnRpdGllcyk7XG5cbiAgICAgIGNvbnN0IG9sZEVudGl0eSA9IHN0YXRlLmVudGl0aWVzW2lkXTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gaXNGdW5jdGlvbihuZXdTdGF0ZU9yRm4pID8gbmV3U3RhdGVPckZuKG9sZEVudGl0eSkgOiBuZXdTdGF0ZU9yRm47XG5cbiAgICAgIGlmIChuZXdTdGF0ZS5oYXNPd25Qcm9wZXJ0eShpZEtleSkgJiYgbmV3U3RhdGVbaWRLZXldICE9PSBvbGRFbnRpdHlbaWRLZXldKSB7XG4gICAgICAgIGlmIChpZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBBa2l0YVVwZGF0ZUlkS2V5RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpc1VwZGF0aW5nSWRLZXkgPSB0cnVlO1xuICAgICAgICBpZFRvVXBkYXRlID0gbmV3U3RhdGVbaWRLZXldO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3RW50aXR5O1xuXG4gICAgICBjb25zdCBtZXJnZWQgPSB7XG4gICAgICAgIC4uLm9sZEVudGl0eSxcbiAgICAgICAgLi4ubmV3U3RhdGVcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9sZEVudGl0eSkpIHtcbiAgICAgICAgbmV3RW50aXR5ID0gbWVyZ2VkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50aXR5ID0gbmV3IG9sZEVudGl0eS5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVkRW50aXRpZXNbaWRUb1VwZGF0ZV0gPSBuZXdFbnRpdHk7XG4gICAgfVxuXG4gICAgbGV0IHVwZGF0ZWRJZHMgPSBzdGF0ZS5pZHM7XG4gICAgbGV0IHN0YXRlRW50aXRpZXMgPSBzdGF0ZS5lbnRpdGllcztcbiAgICBpZiAoaXNVcGRhdGluZ0lkS2V5KSB7XG4gICAgICBjb25zdCBbaWRdID0gaWRzO1xuICAgICAgY29uc3QgeyBbaWRdOiBkZWxldGVkRW50aXR5LCAuLi5yZXN0IH0gPSBzdGF0ZS5lbnRpdGllcztcbiAgICAgIHN0YXRlRW50aXRpZXMgPSByZXN0O1xuICAgICAgdXBkYXRlZElkcyA9IHN0YXRlLmlkcy5tYXAoY3VycmVudCA9PiAoY3VycmVudCA9PT0gaWQgPyBpZFRvVXBkYXRlIDogY3VycmVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi4oc3RhdGUgYXMgYW55KSxcbiAgICAgIGVudGl0aWVzOiB7XG4gICAgICAgIC4uLnN0YXRlRW50aXRpZXMsXG4gICAgICAgIC4uLnVwZGF0ZWRFbnRpdGllc1xuICAgICAgfSxcbiAgICAgIGlkczogdXBkYXRlZElkc1xuICAgIH07XG4gIH1cblxuICBfcmVtb3ZlPFQgZXh0ZW5kcyBFbnRpdHlTdGF0ZT4oc3RhdGU6IFQsIGlkczogSURbXSB8IG51bGwpOiBUIHtcbiAgICBpZiAoIWlkcykgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbChzdGF0ZSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gaWRzLnJlZHVjZSgoYWNjLCBpZCkgPT4ge1xuICAgICAgY29uc3QgeyBbaWRdOiBlbnRpdHksIC4uLnJlc3QgfSA9IGFjYztcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH0sIHN0YXRlLmVudGl0aWVzKTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLihzdGF0ZSBhcyBhbnkpLFxuICAgICAgZW50aXRpZXM6IHJlbW92ZWQsXG4gICAgICBpZHM6IHN0YXRlLmlkcy5maWx0ZXIoY3VycmVudCA9PiBpZHMuaW5kZXhPZihjdXJyZW50KSA9PT0gLTEpXG4gICAgfTtcblxuICAgIGlmIChyZXNldEFjdGl2ZShuZXdTdGF0ZSkpIHtcbiAgICAgIG5ld1N0YXRlLmFjdGl2ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlQWxsPFQgZXh0ZW5kcyBFbnRpdHlTdGF0ZT4oc3RhdGU6IFQpOiBUIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLihzdGF0ZSBhcyBhbnkpLFxuICAgICAgZW50aXRpZXM6IHt9LFxuICAgICAgaWRzOiBbXSxcbiAgICAgIGFjdGl2ZTogbnVsbFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxuICBwcml2YXRlIGtleUJ5KGVudGl0aWVzOiBhbnlbXSwgZW50aXR5Q2xhc3M/OiBOZXdhYmxlPGFueT4sIGlkID0gJ2lkJykge1xuICAgIGNvbnN0IGFjYyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVudGl0aWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBlbnRpdGllc1tpXTtcbiAgICAgIGFjY1tlbnRpdHlbaWRdXSA9IGVudGl0eUNsYXNzID8gbmV3IGVudGl0eUNsYXNzKGVudGl0eSkgOiBlbnRpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgX2NydWQgPSBuZXcgQ1JVRCgpO1xuIl19