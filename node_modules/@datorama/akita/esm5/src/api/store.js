/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { BehaviorSubject, ReplaySubject } from 'rxjs';
import { distinctUntilChanged, map } from 'rxjs/operators';
import { AkitaImmutabilityError, assertDecorator } from '../internal/error';
import { commit, isTransactionInProcess } from '../internal/transaction.internal';
import { isFunction, isPlainObject } from '../internal/utils';
import { deepFreeze } from '../internal/deep-freeze';
import { configKey } from './store-config';
import { __globalState } from '../internal/global-state';
/** *
 * Whether we are in dev mode
  @type {?} */
var __DEV__ = true;
/** @type {?} */
export var __stores__ = {};
/** @enum {number} */
var Actions = {
    NEW_STORE: 0,
    NEW_STATE: 1,
};
export { Actions };
/** @type {?} */
export var rootDispatcher = new ReplaySubject();
/**
 * @param {?} storeName
 * @param {?=} initialState
 * @return {?}
 */
function nextState(storeName, initialState) {
    if (initialState === void 0) { initialState = false; }
    return {
        type: 1 /* NEW_STATE */,
        payload: {
            name: storeName,
            initialState: initialState
        }
    };
}
/**
 * Enable production mode to disable objectFreeze
 * @return {?}
 */
export function enableAkitaProdMode() {
    __DEV__ = false;
}
/**
 * @return {?}
 */
export function isDev() {
    return __DEV__;
}
/**
 * The Root Store that every sub store needs to inherit and
 * invoke `super` with the initial state.
 * @template S
 */
var /**
 * The Root Store that every sub store needs to inherit and
 * invoke `super` with the initial state.
 * @template S
 */
Store = /** @class */ (function () {
    /**
     *
     * Initial the store with the state
     */
    function Store(initialState) {
        /**
         * Whether we are inside transaction *
         */
        this.inTransaction = false;
        this._isPristine = true;
        __globalState.setAction({ type: '@@INIT' });
        __stores__[this.storeName] = this;
        this.setState(function () { return initialState; });
        rootDispatcher.next({
            type: 0 /* NEW_STORE */,
            payload: { store: this }
        });
        isDev() && assertDecorator(this.storeName, this.constructor.name);
    }
    /**
     * @param {?=} loading
     * @return {?}
     */
    Store.prototype.setLoading = /**
     * @param {?=} loading
     * @return {?}
     */
    function (loading) {
        if (loading === void 0) { loading = false; }
        if (loading !== (/** @type {?} */ (this._value())).loading) {
            isDev() && __globalState.setAction({ type: 'Set Loading' });
            this.setState(function (s) { return (/** @type {?} */ (tslib_1.__assign({}, (/** @type {?} */ (s)), { loading: loading }))); });
        }
    };
    /**
     * Update the store's error state.
     */
    /**
     * Update the store's error state.
     * @template T
     * @param {?} error
     * @return {?}
     */
    Store.prototype.setError = /**
     * Update the store's error state.
     * @template T
     * @param {?} error
     * @return {?}
     */
    function (error) {
        if (error !== (/** @type {?} */ (this._value())).error) {
            isDev() && __globalState.setAction({ type: 'Set Error' });
            this.setState(function (s) { return (/** @type {?} */ (tslib_1.__assign({}, (/** @type {?} */ (s)), { error: error }))); });
        }
    };
    /**
     * Select a slice from the store
     *
     * @example
     * this.store.select(state => state.entities)
     *
     */
    /**
     * Select a slice from the store
     *
     * \@example
     * this.store.select(state => state.entities)
     *
     * @template R
     * @param {?} project
     * @return {?}
     */
    Store.prototype._select = /**
     * Select a slice from the store
     *
     * \@example
     * this.store.select(state => state.entities)
     *
     * @template R
     * @param {?} project
     * @return {?}
     */
    function (project) {
        return this.store$.pipe(map(project), distinctUntilChanged());
    };
    /**
     * @return {?}
     */
    Store.prototype._value = /**
     * @return {?}
     */
    function () {
        return this.storeValue;
    };
    Object.defineProperty(Store.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this.constructor[configKey];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "storeName", {
        /**
         * Get the store name
         */
        get: /**
         * Get the store name
         * @return {?}
         */
        function () {
            return this.config && this.config['storeName'];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "isPristine", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isPristine;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * `setState()` is the only way to update a store; It receives a callback function,
     * which gets the current state, and returns a new immutable state,
     * which will be the new value of the store.
     */
    /**
     * `setState()` is the only way to update a store; It receives a callback function,
     * which gets the current state, and returns a new immutable state,
     * which will be the new value of the store.
     * @param {?} newStateFn
     * @param {?=} _rootDispatcher
     * @return {?}
     */
    Store.prototype.setState = /**
     * `setState()` is the only way to update a store; It receives a callback function,
     * which gets the current state, and returns a new immutable state,
     * which will be the new value of the store.
     * @param {?} newStateFn
     * @param {?=} _rootDispatcher
     * @return {?}
     */
    function (newStateFn, _rootDispatcher) {
        if (_rootDispatcher === void 0) { _rootDispatcher = true; }
        /** @type {?} */
        var prevState = this._value();
        this.storeValue = __DEV__ ? deepFreeze(newStateFn(this._value())) : newStateFn(this._value());
        if (prevState === this.storeValue) {
            throw new AkitaImmutabilityError(this.storeName);
        }
        if (!this.store) {
            this.store = new BehaviorSubject(this.storeValue);
            rootDispatcher.next(nextState(this.storeName, true));
            return;
        }
        if (isTransactionInProcess()) {
            this.handleTransaction();
            return;
        }
        this.dispatch(this.storeValue, _rootDispatcher);
    };
    /**
     * @param {?} newStateOrId
     * @param {?=} newState
     * @return {?}
     */
    Store.prototype.update = /**
     * @param {?} newStateOrId
     * @param {?=} newState
     * @return {?}
     */
    function (newStateOrId, newState) {
        __globalState.setAction({ type: 'Update Store' });
        this.setState(function (state) {
            /** @type {?} */
            var value = isFunction(newStateOrId) ? newStateOrId(state) : newStateOrId;
            /** @type {?} */
            var merged = Object.assign({}, state, value);
            return isPlainObject(state) ? merged : new (/** @type {?} */ (state)).constructor(merged);
        });
        this.setDirty();
    };
    /**
     * Sets the store to a pristine state.
     */
    /**
     * Sets the store to a pristine state.
     * @return {?}
     */
    Store.prototype.setPristine = /**
     * Sets the store to a pristine state.
     * @return {?}
     */
    function () {
        this._isPristine = true;
    };
    /**
     * Sets the store to a dirty state, indicating that it is not pristine.
     */
    /**
     * Sets the store to a dirty state, indicating that it is not pristine.
     * @return {?}
     */
    Store.prototype.setDirty = /**
     * Sets the store to a dirty state, indicating that it is not pristine.
     * @return {?}
     */
    function () {
        this._isPristine = false;
    };
    /**
     * @param {?} state
     * @param {?=} _rootDispatcher
     * @return {?}
     */
    Store.prototype.dispatch = /**
     * @param {?} state
     * @param {?=} _rootDispatcher
     * @return {?}
     */
    function (state, _rootDispatcher) {
        if (_rootDispatcher === void 0) { _rootDispatcher = true; }
        this.store.next(state);
        if (_rootDispatcher) {
            rootDispatcher.next(nextState(this.storeName));
            isDev() && __globalState.setAction({ type: 'Set State' });
        }
    };
    Object.defineProperty(Store.prototype, "store$", {
        get: /**
         * @return {?}
         */
        function () {
            return this.store.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * When the transaction ends dispatch the final value once
     * @return {?}
     */
    Store.prototype.watchTransaction = /**
     * When the transaction ends dispatch the final value once
     * @return {?}
     */
    function () {
        var _this = this;
        commit().subscribe(function () {
            _this.inTransaction = false;
            if (isDev() && !__globalState.skipTransactionMsg) {
                __globalState.setAction({ type: '@Transaction' });
            }
            _this.dispatch(_this._value());
            __globalState.currentT = [];
            __globalState.skipTransactionMsg = false;
        });
    };
    /**
     * Listen to the transaction stream
     * @return {?}
     */
    Store.prototype.handleTransaction = /**
     * Listen to the transaction stream
     * @return {?}
     */
    function () {
        if (!this.inTransaction) {
            this.watchTransaction();
            this.inTransaction = true;
        }
    };
    /**
     * @return {?}
     */
    Store.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this === __stores__[this.storeName]) {
            delete __stores__[this.storeName];
        }
    };
    return Store;
}());
/**
 * The Root Store that every sub store needs to inherit and
 * invoke `super` with the initial state.
 * @template S
 */
export { Store };
function Store_tsickle_Closure_declarations() {
    /**
     * Manage the store with BehaviorSubject
     * @type {?}
     */
    Store.prototype.store;
    /**
     * The current state value
     * @type {?}
     */
    Store.prototype.storeValue;
    /**
     * Whether we are inside transaction *
     * @type {?}
     */
    Store.prototype.inTransaction;
    /** @type {?} */
    Store.prototype._isPristine;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvYXBpL3N0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLGVBQWUsRUFBYyxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM1RSxPQUFPLEVBQUUsTUFBTSxFQUFFLHNCQUFzQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDbEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDckQsT0FBTyxFQUFFLFNBQVMsRUFBc0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7Ozs7QUFHekQsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDOztBQUVuQixXQUFhLFVBQVUsR0FBd0MsRUFBRSxDQUFDOzs7SUFHaEUsWUFBUztJQUNULFlBQVM7Ozs7QUFRWCxXQUFhLGNBQWMsR0FBRyxJQUFJLGFBQWEsRUFBVSxDQUFDOzs7Ozs7QUFFMUQsbUJBQW1CLFNBQVMsRUFBRSxZQUFvQjtJQUFwQiw2QkFBQSxFQUFBLG9CQUFvQjtJQUNoRCxPQUFPO1FBQ0wsSUFBSSxtQkFBbUI7UUFDdkIsT0FBTyxFQUFFO1lBQ1AsSUFBSSxFQUFFLFNBQVM7WUFDZixZQUFZLGNBQUE7U0FDYjtLQUNGLENBQUM7Q0FDSDs7Ozs7QUFLRCxNQUFNO0lBQ0osT0FBTyxHQUFHLEtBQUssQ0FBQztDQUNqQjs7OztBQUVELE1BQU07SUFDSixPQUFPLE9BQU8sQ0FBQztDQUNoQjs7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LGtCQUFrQixHQUFHLEtBQUssQ0FBQztTQUMxQyxDQUFDLENBQUM7Ozs7OztJQU1HLGlDQUFpQjs7Ozs7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7U0FDM0I7Ozs7O0lBR0ssMkJBQVc7Ozs7UUFDakIsSUFBSSxJQUFJLEtBQUssVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN2QyxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDbkM7O2dCQXRPTDtJQXdPQyxDQUFBOzs7Ozs7QUFwTEQsaUJBb0xDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1hcCwgSUQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFraXRhSW1tdXRhYmlsaXR5RXJyb3IsIGFzc2VydERlY29yYXRvciB9IGZyb20gJy4uL2ludGVybmFsL2Vycm9yJztcbmltcG9ydCB7IGNvbW1pdCwgaXNUcmFuc2FjdGlvbkluUHJvY2VzcyB9IGZyb20gJy4uL2ludGVybmFsL3RyYW5zYWN0aW9uLmludGVybmFsJztcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi9pbnRlcm5hbC91dGlscyc7XG5pbXBvcnQgeyBkZWVwRnJlZXplIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGVlcC1mcmVlemUnO1xuaW1wb3J0IHsgY29uZmlnS2V5LCBTdG9yZUNvbmZpZ09wdGlvbnMgfSBmcm9tICcuL3N0b3JlLWNvbmZpZyc7XG5pbXBvcnQgeyBfX2dsb2JhbFN0YXRlIH0gZnJvbSAnLi4vaW50ZXJuYWwvZ2xvYmFsLXN0YXRlJztcblxuLyoqIFdoZXRoZXIgd2UgYXJlIGluIGRldiBtb2RlICovXG5sZXQgX19ERVZfXyA9IHRydWU7XG5cbmV4cG9ydCBjb25zdCBfX3N0b3Jlc19fOiB7IFtzdG9yZU5hbWU6IHN0cmluZ106IFN0b3JlPGFueT4gfSA9IHt9O1xuXG5leHBvcnQgY29uc3QgZW51bSBBY3Rpb25zIHtcbiAgTkVXX1NUT1JFLFxuICBORVdfU1RBVEVcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uID0ge1xuICB0eXBlOiBBY3Rpb25zO1xuICBwYXlsb2FkOiBIYXNoTWFwPGFueT47XG59O1xuXG5leHBvcnQgY29uc3Qgcm9vdERpc3BhdGNoZXIgPSBuZXcgUmVwbGF5U3ViamVjdDxBY3Rpb24+KCk7XG5cbmZ1bmN0aW9uIG5leHRTdGF0ZShzdG9yZU5hbWUsIGluaXRpYWxTdGF0ZSA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9ucy5ORVdfU1RBVEUsXG4gICAgcGF5bG9hZDoge1xuICAgICAgbmFtZTogc3RvcmVOYW1lLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVuYWJsZSBwcm9kdWN0aW9uIG1vZGUgdG8gZGlzYWJsZSBvYmplY3RGcmVlemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUFraXRhUHJvZE1vZGUoKSB7XG4gIF9fREVWX18gPSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGV2KCkge1xuICByZXR1cm4gX19ERVZfXztcbn1cblxuLyoqXG4gKiBUaGUgUm9vdCBTdG9yZSB0aGF0IGV2ZXJ5IHN1YiBzdG9yZSBuZWVkcyB0byBpbmhlcml0IGFuZFxuICogaW52b2tlIGBzdXBlcmAgd2l0aCB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JlPFM+IHtcbiAgLyoqIE1hbmFnZSB0aGUgc3RvcmUgd2l0aCBCZWhhdmlvclN1YmplY3QgKi9cbiAgcHJpdmF0ZSBzdG9yZTogQmVoYXZpb3JTdWJqZWN0PFJlYWRvbmx5PFM+PjtcblxuICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgdmFsdWUgKi9cbiAgcHJpdmF0ZSBzdG9yZVZhbHVlOiBTO1xuXG4gIC8qKiBXaGV0aGVyIHdlIGFyZSBpbnNpZGUgdHJhbnNhY3Rpb24gKiovXG4gIHByaXZhdGUgaW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX2lzUHJpc3RpbmUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKlxuICAgKiBJbml0aWFsIHRoZSBzdG9yZSB3aXRoIHRoZSBzdGF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5pdGlhbFN0YXRlKSB7XG4gICAgX19nbG9iYWxTdGF0ZS5zZXRBY3Rpb24oeyB0eXBlOiAnQEBJTklUJyB9KTtcbiAgICBfX3N0b3Jlc19fW3RoaXMuc3RvcmVOYW1lXSA9IHRoaXM7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiBpbml0aWFsU3RhdGUpO1xuICAgIHJvb3REaXNwYXRjaGVyLm5leHQoe1xuICAgICAgdHlwZTogQWN0aW9ucy5ORVdfU1RPUkUsXG4gICAgICBwYXlsb2FkOiB7IHN0b3JlOiB0aGlzIH1cbiAgICB9KTtcbiAgICBpc0RldigpICYmIGFzc2VydERlY29yYXRvcih0aGlzLnN0b3JlTmFtZSwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfVxuXG4gIHNldExvYWRpbmcobG9hZGluZyA9IGZhbHNlKSB7XG4gICAgaWYgKGxvYWRpbmcgIT09ICh0aGlzLl92YWx1ZSgpIGFzIFMgJiB7IGxvYWRpbmc6IGJvb2xlYW4gfSkubG9hZGluZykge1xuICAgICAgaXNEZXYoKSAmJiBfX2dsb2JhbFN0YXRlLnNldEFjdGlvbih7IHR5cGU6ICdTZXQgTG9hZGluZycgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHMgPT4gKHsgLi4uKHMgYXMgb2JqZWN0KSwgbG9hZGluZyB9IGFzIGFueSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHN0b3JlJ3MgZXJyb3Igc3RhdGUuXG4gICAqL1xuICBzZXRFcnJvcjxUPihlcnJvcjogVCkge1xuICAgIGlmIChlcnJvciAhPT0gKHRoaXMuX3ZhbHVlKCkgYXMgUyAmIHsgZXJyb3I6IGFueSB9KS5lcnJvcikge1xuICAgICAgaXNEZXYoKSAmJiBfX2dsb2JhbFN0YXRlLnNldEFjdGlvbih7IHR5cGU6ICdTZXQgRXJyb3InIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZShzID0+ICh7IC4uLihzIGFzIG9iamVjdCksIGVycm9yIH0gYXMgYW55KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHNsaWNlIGZyb20gdGhlIHN0b3JlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmUuc2VsZWN0KHN0YXRlID0+IHN0YXRlLmVudGl0aWVzKVxuICAgKlxuICAgKi9cbiAgX3NlbGVjdDxSPihwcm9qZWN0OiAoc3RvcmU6IFMpID0+IFIpOiBPYnNlcnZhYmxlPFI+IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZSQucGlwZShcbiAgICAgIG1hcChwcm9qZWN0KSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApO1xuICB9XG5cbiAgX3ZhbHVlKCk6IFMge1xuICAgIHJldHVybiB0aGlzLnN0b3JlVmFsdWU7XG4gIH1cblxuICBnZXQgY29uZmlnKCk6IFN0b3JlQ29uZmlnT3B0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3JbY29uZmlnS2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0b3JlIG5hbWVcbiAgICovXG4gIGdldCBzdG9yZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnWydzdG9yZU5hbWUnXTtcbiAgfVxuXG4gIGdldCBpc1ByaXN0aW5lKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ByaXN0aW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIGBzZXRTdGF0ZSgpYCBpcyB0aGUgb25seSB3YXkgdG8gdXBkYXRlIGEgc3RvcmU7IEl0IHJlY2VpdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24sXG4gICAqIHdoaWNoIGdldHMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCByZXR1cm5zIGEgbmV3IGltbXV0YWJsZSBzdGF0ZSxcbiAgICogd2hpY2ggd2lsbCBiZSB0aGUgbmV3IHZhbHVlIG9mIHRoZSBzdG9yZS5cbiAgICovXG4gIHNldFN0YXRlKG5ld1N0YXRlRm46IChzdGF0ZTogUmVhZG9ubHk8Uz4pID0+IFMsIF9yb290RGlzcGF0Y2hlciA9IHRydWUpIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl92YWx1ZSgpO1xuICAgIHRoaXMuc3RvcmVWYWx1ZSA9IF9fREVWX18gPyBkZWVwRnJlZXplKG5ld1N0YXRlRm4odGhpcy5fdmFsdWUoKSkpIDogbmV3U3RhdGVGbih0aGlzLl92YWx1ZSgpKTtcblxuICAgIGlmIChwcmV2U3RhdGUgPT09IHRoaXMuc3RvcmVWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEFraXRhSW1tdXRhYmlsaXR5RXJyb3IodGhpcy5zdG9yZU5hbWUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdG9yZSkge1xuICAgICAgdGhpcy5zdG9yZSA9IG5ldyBCZWhhdmlvclN1YmplY3QodGhpcy5zdG9yZVZhbHVlKTtcbiAgICAgIHJvb3REaXNwYXRjaGVyLm5leHQobmV4dFN0YXRlKHRoaXMuc3RvcmVOYW1lLCB0cnVlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzVHJhbnNhY3Rpb25JblByb2Nlc3MoKSkge1xuICAgICAgdGhpcy5oYW5kbGVUcmFuc2FjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2godGhpcy5zdG9yZVZhbHVlLCBfcm9vdERpc3BhdGNoZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRjdXQgZm9yIGBzZXRTdGF0ZSgpYC5cbiAgICogSXQgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHBhc3MgdGhlIHdob2xlIHN0YXRlIG9iamVjdCBpbnN0ZWFkIG9mIG1lcmdpbmcgYSBwYXJ0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JlLnVwZGF0ZShuZXdTdGF0ZSlcbiAgICovXG4gIHVwZGF0ZShuZXdTdGF0ZTogUGFydGlhbDxTPik7XG4gIHVwZGF0ZShuZXdTdGF0ZTogKHN0YXRlOiBSZWFkb25seTxTPikgPT4gUGFydGlhbDxTPik7XG4gIHVwZGF0ZShpZDogSUQgfCBJRFtdIHwgbnVsbCwgbmV3U3RhdGU6IFBhcnRpYWw8Uz4pO1xuICB1cGRhdGUobmV3U3RhdGVPcklkOiBQYXJ0aWFsPFM+IHwgSUQgfCBJRFtdIHwgbnVsbCB8ICgoc3RhdGU6IFJlYWRvbmx5PFM+KSA9PiBQYXJ0aWFsPFM+KSwgbmV3U3RhdGU/OiBQYXJ0aWFsPFM+KSB7XG4gICAgX19nbG9iYWxTdGF0ZS5zZXRBY3Rpb24oeyB0eXBlOiAnVXBkYXRlIFN0b3JlJyB9KTtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGlzRnVuY3Rpb24obmV3U3RhdGVPcklkKSA/IG5ld1N0YXRlT3JJZChzdGF0ZSkgOiBuZXdTdGF0ZU9ySWQ7XG4gICAgICBsZXQgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHZhbHVlKTtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHN0YXRlKSA/IG1lcmdlZCA6IG5ldyAoc3RhdGUgYXMgYW55KS5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0RGlydHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdG9yZSB0byBhIHByaXN0aW5lIHN0YXRlLlxuICAgKi9cbiAgc2V0UHJpc3RpbmUoKSB7XG4gICAgdGhpcy5faXNQcmlzdGluZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RvcmUgdG8gYSBkaXJ0eSBzdGF0ZSwgaW5kaWNhdGluZyB0aGF0IGl0IGlzIG5vdCBwcmlzdGluZS5cbiAgICovXG4gIHNldERpcnR5KCkge1xuICAgIHRoaXMuX2lzUHJpc3RpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgZGlzcGF0Y2goc3RhdGU6IFMsIF9yb290RGlzcGF0Y2hlciA9IHRydWUpIHtcbiAgICB0aGlzLnN0b3JlLm5leHQoc3RhdGUpO1xuICAgIGlmIChfcm9vdERpc3BhdGNoZXIpIHtcbiAgICAgIHJvb3REaXNwYXRjaGVyLm5leHQobmV4dFN0YXRlKHRoaXMuc3RvcmVOYW1lKSk7XG4gICAgICBpc0RldigpICYmIF9fZ2xvYmFsU3RhdGUuc2V0QWN0aW9uKHsgdHlwZTogJ1NldCBTdGF0ZScgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgc3RvcmUkKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHRyYW5zYWN0aW9uIGVuZHMgZGlzcGF0Y2ggdGhlIGZpbmFsIHZhbHVlIG9uY2VcbiAgICovXG4gIHByaXZhdGUgd2F0Y2hUcmFuc2FjdGlvbigpIHtcbiAgICBjb21taXQoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5pblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICBpZiAoaXNEZXYoKSAmJiAhX19nbG9iYWxTdGF0ZS5za2lwVHJhbnNhY3Rpb25Nc2cpIHtcbiAgICAgICAgX19nbG9iYWxTdGF0ZS5zZXRBY3Rpb24oeyB0eXBlOiAnQFRyYW5zYWN0aW9uJyB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5fdmFsdWUoKSk7XG4gICAgICBfX2dsb2JhbFN0YXRlLmN1cnJlbnRUID0gW107XG4gICAgICBfX2dsb2JhbFN0YXRlLnNraXBUcmFuc2FjdGlvbk1zZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byB0aGUgdHJhbnNhY3Rpb24gc3RyZWFtXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZVRyYW5zYWN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pblRyYW5zYWN0aW9uKSB7XG4gICAgICB0aGlzLndhdGNoVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRoaXMuaW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcyA9PT0gX19zdG9yZXNfX1t0aGlzLnN0b3JlTmFtZV0pIHtcbiAgICAgIGRlbGV0ZSBfX3N0b3Jlc19fW3RoaXMuc3RvcmVOYW1lXTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==